{
    "version": "https://jsonfeed.org/version/1",
    "title": "Phoenix • All posts by \"datalinkx\" category",
    "description": "Every day is a chance to learn something new",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/11/25/Datalinkx%E6%A8%A1%E5%9D%97%E8%AE%B2%E8%A7%A31/",
            "url": "http://example.com/2025/11/25/Datalinkx%E6%A8%A1%E5%9D%97%E8%AE%B2%E8%A7%A31/",
            "title": "Datalinkx模块讲解1",
            "date_published": "2025-11-25T13:40:43.000Z",
            "content_html": "<h2 id=\"datalinkx-messagehub与datalinkx-sse\"><a class=\"markdownIt-Anchor\" href=\"#datalinkx-messagehub与datalinkx-sse\">#</a> Datalinkx-messageHub 与 Datalinkx-SSE</h2>\n<ul>\n<li>用于 datalinkx-job 和 datalinkx-server 之间的异步通信，这个模块只有在推送流转进度中才使用，job 是生成者，检测流转任务的进度数据后，调用生产者 api 把数据发送到 redis 中，datlainkx-sse 是消费者，注册一个常驻代理线程，实时监控 redis 中的数据，监听到后，回调到标记了 @MessageHub 注解的方法中</li>\n</ul>\n<h3 id=\"redis-stream结构作为消息队列\"><a class=\"markdownIt-Anchor\" href=\"#redis-stream结构作为消息队列\">#</a> Redis stream 结构作为消息队列</h3>\n<ul>\n<li>一条消息只能由一个消费者组中的一个消费者消费。</li>\n</ul>\n<h3 id=\"topicreloadtask类\"><a class=\"markdownIt-Anchor\" href=\"#topicreloadtask类\">#</a> TopicReloadTask 类</h3>\n<ul>\n<li>是一个定时任务，用来周期性从数据库中读取所有 topic，并把他们更新到 redis 的白名单集合中，更新时采用删除原来的名单，再写入新的名单（lua 脚本控制原子性，避免删除后失败，未写入新名单）<br>\n用于几个地方：发送端检查是否有该 topic、消费端是否订阅了存在的 topic。实际上本项目只需要用 1 个 topic 即可</li>\n</ul>\n<h3 id=\"topicdaemonwarden类\"><a class=\"markdownIt-Anchor\" href=\"#topicdaemonwarden类\">#</a> TopicDaemonWarden 类</h3>\n<ul>\n<li>用于注册定时执行器 Timer 并周期性调度任务</li>\n</ul>\n<h3 id=\"service包\"><a class=\"markdownIt-Anchor\" href=\"#service包\">#</a> Service 包</h3>\n<ul>\n<li>主要是 redis 包里面的 stream 类：封装了消息队列的发送和接收，提供给数据流转时的调用，其中发送是数据流转的时候推送进消息队列中，而接收这个消费者动作，是一开始就初始化了一个常驻线程去监控 redis 数据（ConsumerConfig 类负责发现消费者方法【带有 messageHub 注解的方法，都在 SSE 模块下】+ 注册消费者），RedisStreamProcessor 负责真正的订阅 stream + 启动线程持续消费消息。</li>\n</ul>\n<h3 id=\"datalinkx-sse模块\"><a class=\"markdownIt-Anchor\" href=\"#datalinkx-sse模块\">#</a> Datalinkx-sse 模块</h3>\n<ul>\n<li>这一块主要是用于维护 SSE 的连接、传输，与 messagehub 连接紧密，因为 messagehub 模块是用于把消息生产到 topic 中，然后 SSE 中的三个消费者（已在 messagehub 中注册为消费者）把消息读取，并通过 SSE 途径推送到前端。这个 SSE 连接，是用户向 server 模块的控制层请求建立的。这一块 SSE 监督的是新更新的信息，但是后端只会把信息推送到前端，前端负责是要更新哪个任务的状态，在任务结束时，后端会写入数据库。</li>\n</ul>\n<h2 id=\"datalinkx-client模块\"><a class=\"markdownIt-Anchor\" href=\"#datalinkx-client模块\">#</a> Datalinkx-client 模块</h2>\n<ul>\n<li>主要功能是为项目的每个模块提供远程调用功能，主要是通过 retrofit2 进行远程调用，包括对 flink、datalinkxjob 模块、seatunnel 进行调用。</li>\n</ul>\n<h3 id=\"对flink模块的调用\"><a class=\"markdownIt-Anchor\" href=\"#对flink模块的调用\">#</a> 对 flink 模块的调用</h3>\n<p>通过 HTTP 调用 Flink 的 API，获取作业状态、作业指标、异常信息以及停止作业等操作。对于 client 的返回值，做了一个统一的封装处理，使用了 JsonNode 形式作为响应数据，会以 json 形式返回，类似：<br>\n{<br>\n“user-task-accumulators”: [<br>\n{<br>\n“name”: “numRecordsOut”,<br>\n“type”: “Long”,<br>\n“value”: “123456”<br>\n},<br>\n{<br>\n“name”: “numRecordsIn”,<br>\n“type”: “Long”,<br>\n“value”: “120000”<br>\n}<br>\n]<br>\n}<br>\n 那么你如果有多种返回数据形式时，定义好 response 类，然后加上这个标志：<br>\n@Data<br>\npublic class FlinkJobAccumulators {</p>\n<pre><code>@JsonProperty(&quot;user-task-accumulators&quot;)\nList&lt;UserTaskAccumulator&gt; userTaskAccumulators;\n\n@Data\npublic static class UserTaskAccumulator &#123;\n    private String name;\n    private String type;\n    private String value;\n&#125;\n</code></pre>\n<p>}<br>\n 他就会自动封装到你这个类型中了<br>\n但是，可以直接不用统一的返回值，编写远程调用的时候，返回值直接用自己封装的类</p>\n<h3 id=\"向外暴露一个datalinkxclientutils类\"><a class=\"markdownIt-Anchor\" href=\"#向外暴露一个datalinkxclientutils类\">#</a> 向外暴露一个 DatalinkXClientUtils 类</h3>\n<ul>\n<li>用于创建远程服务客户端的动态代理 + 注入 Spring 容器，供其他类 使用。<br>\n因为目前定义 Retrofit 客户端接口（ FlinkClient、DatalinkXJobClient）本身不具备逻辑，它们需要 Retrofit 动态代理才能工作，所以必须主动创建并注册为 Bean。所以同个 utils 这个类，来创建实例。</li>\n<li>其他模块如果想要用某个远程接口，那么就调用这个 utils，会把 client 进行动态代理（封装请求之类的操作，因为之前我们只是定义了接口，并不是属于 retrofit 的操作，进行动态代理封装之后，才能够进行请求操作），然后返回实例给调用方。</li>\n</ul>\n<h2 id=\"common模块\"><a class=\"markdownIt-Anchor\" href=\"#common模块\">#</a> Common 模块</h2>\n<ul>\n<li>这个模块主要放一些静态变量、异常处理、统一响应结果以及工具类</li>\n</ul>\n<h2 id=\"connect模块\"><a class=\"markdownIt-Anchor\" href=\"#connect模块\">#</a> Connect 模块</h2>\n<ul>\n<li>这个模块用于数据库的连接、构建读取、写入信息。首先按照数据源的类型分为 JDBC 和非 JDBC。比如 JDBC 类定义了加载数据库驱动程序、创建连接对象、获取数据库操作对象、执行查询、释放资源、构建 JDBC source（读取）或者 sink（写入）的操作。然后 mysql /oracle 属于 JDBC 类型，就继承 JDBC，把不同的地方进行重写即可。这里只是按照模板模式的方法，先定义了父类，子类只需要实现不同点就行，如果觉得麻烦，可以自己编写每个数据源的读取、写入的方法，然后给数据流转类调用即可。</li>\n<li>对于读取、写入操作：是需要根据全量、增量、数据表信息、字段等信息，从数据库读取 / 写入此操作，这里封装的是提交给 flinkx 的 Unit 单元，最终会形成这样：<br>\n{<br>\n“job”: {<br>\n“content”: [<br>\n{<br>\n“reader”: {<br>\n“name”: “mysqlreader”,<br>\n“parameter”: {<br>\n“connection”: […],<br>\n“column”: […],<br>\n“where”: “id &gt; 100”,<br>\n“username”: “…”,<br>\n“password”: “…”<br>\n}<br>\n},<br>\n“writer”: {<br>\n“name”: “mysqlwriter”,<br>\n“parameter”: {<br>\n“connection”: […],<br>\n“column”: […],<br>\n“writeMode”: “insert”<br>\n}<br>\n}<br>\n}<br>\n]<br>\n}<br>\n}<br>\n 然后提交给 flinkx 去执行</li>\n</ul>\n<p>对于如何获取这个 Driver 类，DsDriverFactory 是一个静态工厂类，提供给外界创建 Driver 的实例，外界（数据流转时）会给一个 connectId 给工厂类，根据这个 id 解析出属于哪一个类型，然后把类（MysqlDriver / OracleDriver 等）实例化出来返回给数据流转操作，然后就会根据这个类去获取读取源以及写入源。</p>\n<p>所以这个模块看起来多，其实内容就两个：1、定义一个数据库实例； 2、向外开放一个工厂类，返回实例给外界</p>\n<p>新增数据源：新增一个包（与 Driver 同层）然后实现读写即可，因为加载类的时候，会根据包路径来加载，把包放在可以加载到的地方即可。</p>\n",
            "tags": [
                "datalinkx"
            ]
        },
        {
            "id": "http://example.com/2025/05/13/DatalinkX/",
            "url": "http://example.com/2025/05/13/DatalinkX/",
            "title": "DatalinkX",
            "date_published": "2025-05-12T16:35:28.000Z",
            "content_html": "<p>DatalinkX 是一个基于 Flink 的异构数据源流转服务，用来作为数据源之间的数据同步工具，通过抽象异构数据源驱动加借助 FlinkX 开源组件屏蔽数据源间不同的通信协议，通过页面化配置数据同步任务的方式简化数据库同步流程，并通过 Xxl-Job 组件实现定时调度。</p>\n<h2 id=\"模块设置\"><a class=\"markdownIt-Anchor\" href=\"#模块设置\">#</a> 模块设置</h2>\n<ul>\n<li>业务数据管理模块：负责管理数据源和同步任务的增删改查。包含数据源管理、任务管理等。</li>\n<li>同步任务管理模块：借助 xx1-job 实现任务调度管理，确保异构数据源的定时同步和实时更新需求，同时支持批量任务管理，提高任务调度的效率。</li>\n<li>RPC 通信模块：利用 Retrofit2 实现分布式服务间的 RPC 调用，提供高效的数据请求和响应机制支持各模块间的数据传输和服务调用。</li>\n<li>数据源驱动模块：负责异构数据源的驱动配置，兼容多类型数据源的连接、读取和写入操作，为业务数据管理和同步提供支持。</li>\n<li>消息通道模块：采用 Redis Stream 实现分布式消息队列，保障各模块间的消息通信效率和数据传 5.<br>\n 输的可靠性。</li>\n<li>实时刷新前端模块：通过 SSE 技术实现数据的实时推送，配合 Ant Design 在前端即时刷新数据提供用户友好的动态体验。</li>\n<li>公共模块：包含系统基础功能、工具方法和通用接口，实现各模块间的共享，提升系统的可维护性和复用性。</li>\n<li>FlinkX 模块：负责人规模数据的实时同步、数据清洗和格式转换，支持流式和批量数据的整合处理，为系统提供数据支持。<br>\n数据清洗与转换模块：基于 Flinkx 的清洗能力，对不同数据源的数据进行标准化、过滤和转换以确保进入系统的数据一致性。</li>\n</ul>\n<h2 id=\"重要模块\"><a class=\"markdownIt-Anchor\" href=\"#重要模块\">#</a> 重要模块</h2>\n<ul>\n<li>\n<h3 id=\"消息队列sse实现实时推送\"><a class=\"markdownIt-Anchor\" href=\"#消息队列sse实现实时推送\">#</a> 消息队列 + SSE 实现实时推送</h3>\n<ol>\n<li>首先基于自定义注解 @messageHub 标注消费者方法，在程序运行初始化完 Bean 之后，实现对每个 Bean 进行循环检查，寻找带该注解的方法，找到后将其注册成消费者。</li>\n<li>基于 Redis 的 stream 数据结构实现轻量级的消息队列，出于两点原因选择该方式，首先是本项目只需要使用消息队列实现任务状态和任务进度的推送，不需要严格意义上的高可用、低延迟，其次是 RabbitMQ 或者是 Kafka 服务的复杂性，一个健壮的项目并不是引入越多的中间件会越好，而是 Bug 越少越好，或者说出 Bug 概率越低越好。而 Redis 的 stream 借助了很多 Kafka 的设计思路，而且更轻量级。</li>\n<li>消费者的注册，其实是非常简单的一件事，只需要带有 @messageHub 的，就创建一个线程监听注解中配置的消息地址，监听到消息后回调给该消费者，并返回 ACK 标记消息已被消费，如果在消费过程中出现故障，则会继续在 pending 队列中消费，一般会重试 4 次，如果消费不了，只能是放弃，因为这并不是一个十分重要的操作，丢失部分进度消息是用户能够接收的。</li>\n<li>基于 SSE 实例实现消息实时推送，SSE 是使用流信息向浏览器进行信息推送，也就是信息不是一次性的，而是连续不断的，类似于视频的播放。SSE 是一个单向通信，只能服务器向浏览器发送，这里不选择 websocket 的原因和 2 一样，基于业务层面去考虑。</li>\n</ol>\n</li>\n<li>\n<h3 id=\"抽象数据源driver设计\"><a class=\"markdownIt-Anchor\" href=\"#抽象数据源driver设计\">#</a> 抽象数据源 Driver 设计</h3>\n<p>​       该项目是支持异构数据源同步的，所以会有很多种数据源，进行每种数据源连接是确实可以使用 if else 去定义，但是这并不好维护，而且可拓展性十分差，想象一下每次新增一个数据源就写多一个 if else，代码的可读性也会很差，所以这里会基于模板模式和工厂模式对数据源驱动的获取进行抽象。</p>\n<p>​\t我们把数据源实例抽象为几个步骤，读写分离，然后分别定义为接口，将支持 JDBC 的数据源做一种实现，不支持 JDBC 的数据源也做一种实现。每种实现又有一个基础类去实现基础功能。</p>\n<p>如下图所示：</p>\n<p><img src=\"image1.png\" alt=\"image1\"></p>\n<ol>\n<li>\n<p>DsDriverFactory 遵循工厂设计原则，每个数据源必要信息通过压缩算法返回一个唯一字符串 connectld，DsDriverFactory 向外暴露 getDsReader、getDsWriter 方法，通过解析 connectld 得到数据源 type，根据数据源 type 获取对应 Driver.class 并通过反射生成对应的驱动对象。</p>\n</li>\n<li>\n<p>要新增数据源，比如新增一个 Mysql 的数据源，那么只需要继承 JDBC 这个类，JDBC 这个类已经实现了部分基本的功能，并制定了相应的执行流程，Mysql 继承之后，只需要把获取数据源 JdbcUrl 这种每个数据源都不同的抽象方法给实现了就行。</p>\n</li>\n<li>\n<p>总体流程就是，用户提交了注册新数据源的信息之后，注册信息会存入数据库中，等到创建流转任务时，会获取数据源下的数据表，这时就调用 DsDriverFactory 获取数据源实例，并调用实例中的方法获取对应的数据 / 写入数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">PACKAGE_PREFIX</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.datalinkx.driver.dsdriver.&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">getDriverClass</span><span class=\"params\">(String driverName)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PACKAGE_PREFIX + driverName.toLowerCase() + <span class=\"string\">&quot;driver&quot;</span> + <span class=\"string\">&quot;.&quot;</span> + ConnectIdUtils.toPascalCase(driverName) + <span class=\"string\">&quot;Driver&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//getDriver 方法依赖于 ConnectIdUtils 和 getDriverClass 方法来确定应该加载和实例化哪个驱动类。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDsDriver <span class=\"title function_\">getDriver</span><span class=\"params\">(String connectId)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">dsType</span> <span class=\"operator\">=</span> ConnectIdUtils.getDsType(connectId);</span><br><span class=\"line\">        <span class=\"comment\">//拼接地址，也就是包的地址，来获取对应的类名，并返回给DsServiceImpl类，让他知道用的是哪个实现类，这就是用来替代无数个if else的关键地方</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">driverClassName</span> <span class=\"operator\">=</span> getDriverClass(dsType);</span><br><span class=\"line\">        Class&lt;?&gt; driverClass = Class.forName(driverClassName);</span><br><span class=\"line\">        Constructor&lt;?&gt; constructor = driverClass.getDeclaredConstructor(String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (IDsDriver) constructor.newInstance(connectId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IStreamDriver <span class=\"title function_\">getStreamDriver</span><span class=\"params\">(String connectId)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">dsType</span> <span class=\"operator\">=</span> ConnectIdUtils.getDsType(connectId);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">driverClassName</span> <span class=\"operator\">=</span> getDriverClass(dsType);</span><br><span class=\"line\">        Class&lt;?&gt; driverClass = Class.forName(driverClassName);</span><br><span class=\"line\">        Constructor&lt;?&gt; constructor = driverClass.getDeclaredConstructor(String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (IStreamDriver) constructor.newInstance(connectId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDsReader <span class=\"title function_\">getDsReader</span><span class=\"params\">(String connectId)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * getDriver(connectId) 返回的是一个 IDsDriver 类型的对象，然后将其强制转换为 IDsReader 类型。这种转换能够成功执行的前提是：</span></span><br><span class=\"line\"><span class=\"comment\">         * IDsReader 接口继承自 IDsDriver 接口：如果 IDsReader 接口是 IDsDriver 接口的子接口，那么所有的 IDsReader 实现也必然是 IDsDriver 的实现。</span></span><br><span class=\"line\"><span class=\"comment\">         * 这种情况下，转换是合法的，因为 IDsReader 是 IDsDriver 的子类型。</span></span><br><span class=\"line\"><span class=\"comment\">         * 实现类的兼容性：调用 getDriver(connectId) 方法返回的具体实现类必须同时实现了 IDsDriver 和 IDsReader 接口。这是类型转换能够成功的关键。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (IDsReader) getDriver(connectId);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;driver load error&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;driver load error&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;can not initialize driver&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDsWriter <span class=\"title function_\">getDsWriter</span><span class=\"params\">(String connectId)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (IDsWriter) getDriver(connectId);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;driver load error&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;driver load error&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;can not initialize driver&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<h3 id=\"xxl-job平台\"><a class=\"markdownIt-Anchor\" href=\"#xxl-job平台\">#</a> XXL-Job 平台</h3>\n<p>​\txxl-job 是一个分布式任务调度平台，核心思想是将调度任务抽象成为调度器和执行器，平台本身不承担业务逻辑，只负责发起调度请求后，由执行器接收调度请求并执行任务，这里的任务被抽象为分散的 JobHandler。JobHandler 分散到各个业务代码中，依 netty 保持与调度器的交互，通过这种方式即可实现调度与任务相互解耦，从而提高系统整体的稳定性和拓展性。如下图：</p>\n<p><img src=\"image2.png\" alt=\"image2\"></p>\n<ol>\n<li>\n<p>调度器只需要借助 maven 打包 xxl-job 的 admin 即可，然后 java -jar 把 jar 包运行起来即可，或者是用 docker 直接部署，而执行器则放在项目中的 Job 模块下，使用 @XxlJob (“XXX”) 在方法上定义执行器即可</p>\n</li>\n<li>\n<p>为了解决 xxl-job 登录的问题，这里会使用一个拦截器，拦截器逻辑非常朴实无华，在发请求之前，判断 cookieValue 是否存在，如果不存在就通过 datalinkx-client 的能力发起一次登录请求。登陆后保存 cookie 加到原请求中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> chain.request();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tResponse response;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (StringUtils.isEmpty(cookieValue)) &#123;</span><br><span class=\"line\">\t\t\t\tretrofit2.<span class=\"type\">Response</span> <span class=\"variable\">loginResp</span> <span class=\"operator\">=</span> xxlLoginClient.login(username, passwd, <span class=\"string\">&quot;on&quot;</span>).execute();</span><br><span class=\"line\">\t\t\t\tcookieValue = loginResp.headers().get(SET_COOKIE_HEADER);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (StringUtils.isNotEmpty(cookieValue)) &#123;<span class=\"comment\">//检查是否成功获取了 Cookie 值</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//如果获取了 Cookie，则创建一个新的请求，将 Cookie 添加到请求头中</span></span><br><span class=\"line\">\t\t\t\t<span class=\"type\">Request</span> <span class=\"variable\">newRequest</span> <span class=\"operator\">=</span> chain.request().newBuilder()</span><br><span class=\"line\">\t\t\t\t\t\t.addHeader(HEADER_COOKIE, cookieValue)</span><br><span class=\"line\">\t\t\t\t\t\t.build();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//使用新的请求继续执行链式调用，获取响应</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//当前拦截器已经完成了对请求的处理，将请求传递给拦截器链中的下一个拦截器继续处理</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 最后一个拦截器处理请求后，不再调用 proceed，而是直接将请求发送到服务器。服务器的响应返回，按相反顺序通过拦截器链。</span></span><br><span class=\"line\">\t\t\t\tresponse = chain.proceed(newRequest);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.error(<span class=\"string\">&quot;xxl-job login error&quot;</span>);</span><br><span class=\"line\">\t\t\t\tresponse = chain.proceed(chain.request());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (response.code() == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">ResponseBody</span> <span class=\"variable\">responseBody</span> <span class=\"operator\">=</span> response.body();</span><br><span class=\"line\">\t\t\t<span class=\"type\">MediaType</span> <span class=\"variable\">contentType</span> <span class=\"operator\">=</span> responseBody != <span class=\"literal\">null</span> ? responseBody.contentType() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (contentType != <span class=\"literal\">null</span> &amp;&amp; contentType.subtype().equals(<span class=\"string\">&quot;json&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">String</span> <span class=\"variable\">bodyString</span> <span class=\"operator\">=</span> getBody(response);</span><br><span class=\"line\">\t\t\t\tbodyString = bodyString.replaceFirst(<span class=\"string\">&quot;\\&quot;result\\&quot;:\\\\s*\\&quot;\\\\s*\\&quot;&quot;</span>, <span class=\"string\">&quot;\\&quot;result\\&quot;: null&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">ResponseBody</span> <span class=\"variable\">body</span> <span class=\"operator\">=</span> ResponseBody.create(contentType, bodyString);</span><br><span class=\"line\">\t\t\t\tresponse = response.newBuilder().body(body).build();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> response;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p>流转任务的生命钩子函数设计</p>\n<p>​\t通常的模板方法模式中会设计一个 abstract 的抽象方法，交给它的子类实现，这个方法称为模板方法。而钩子方法，是对于抽象方法或者接口中定义的方法的一个空实现，也是模板方法模式的一种实现方式。设计钩子方法的主要目的是干预执行流程，使得控制行为流程更加灵活，更符合实际业务的需求。在该项目流转任务的生命周期都是基于钩子方法 + 模板实现的，任务由 xxl-job 调度中心通过 netty 回调到 DataTransHandler 执行器中，执行器中注入任务触发类 DataTransferAction，由 doAction 开始一次任务的执行，而 FlinkAction 是继承的 AbstractDataTransferAction 实现各种模板和钩子方法:</p>\n<p>​\t六个钩子方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">begin</span><span class=\"params\">(D info)</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">end</span><span class=\"params\">(D info, <span class=\"type\">int</span> status, String errmsg)</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">beforeExec</span><span class=\"params\">(U unit)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(U unit)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkResult</span><span class=\"params\">(U unit)</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterExec</span><span class=\"params\">(U unit, <span class=\"type\">boolean</span> success, String errorMsg)</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> U <span class=\"title function_\">convertExecUnit</span><span class=\"params\">(D info)</span>;</span><br></pre></td></tr></table></figure>\n<p>​\tdoAction 串联生命周期：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doAction</span><span class=\"params\">(T actionInfo)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取job详情</span></span><br><span class=\"line\">    <span class=\"type\">D</span> <span class=\"variable\">detail</span> <span class=\"operator\">=</span> getJobDetail(actionInfo);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">error</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 准备执行job</span></span><br><span class=\"line\">        begin(detail);</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">        <span class=\"comment\">// 遍历执行启动flink任务</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每个单元执行前的准备</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isStop()) &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;logkill trigger&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            beforeExec(unit)</span><br><span class=\"line\">            <span class=\"comment\">// 启动任务</span></span><br><span class=\"line\">            execute(unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;user stop&quot;</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;execute flink task error.&quot;</span>, e);</span><br><span class=\"line\">            unitCount.decrementAndGet();</span><br><span class=\"line\">            afterExec(unit, <span class=\"literal\">false</span>, e.getMessage());</span><br><span class=\"line\">            error.append(e.getMessage()).append(<span class=\"string\">&quot;\\r\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 整个Job结束后的处理</span></span><br><span class=\"line\">        end(detail, error.length() == <span class=\"number\">0</span> ? JOB_STATUS_SUCCESS : JOB_STATUS_ERROR, error.length() == <span class=\"number\">0</span> ? <span class=\"string\">&quot;success&quot;</span> : error.toString());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;Stop task by user.&quot;</span>);</span><br><span class=\"line\">        JobUtils.cntx().setCanceled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        end(detail, JOB_STATUS_STOP, <span class=\"string\">&quot;cancel the job&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;sync failed&quot;</span>, e);</span><br><span class=\"line\">        end(detail, JOB_STATUS_ERROR, e.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t这个方法可谓是整个 datalinkx 的灵魂，核心中的核心，最核心的代码，我们通过这个方法将一个流转任务的生命周期串联起来。<br>\n这样真正的实现类 DataTransferAction.java 只需要继承 AbstractDataTransferAction 实现各个具体的生命周期方法即可，Xx1-Job 回调来的方法直接调用 FlinkAction 继承的 doAction 方法即可将任务串联执行。</p>\n</li>\n</ul>\n",
            "tags": [
                "datalinkx"
            ]
        }
    ]
}